-- ============================================================
-- HomeFix SmartMail v4.0 ‚Äî Queue + Templates + Attachments
-- ============================================================

-- 0) Prereqs (run once in SQL Editor; do NOT commit the key)
-- alter database postgres
--   set app.settings.fn_url = 'https://xnubmphixlpkyqfhghup.supabase.co/functions/v1';
-- alter database postgres
--   set app.settings.service_role_key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhudWJtcGhpeGxwa3lxZmhnaHVwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAyNTE0NjEsImV4cCI6MjA3NTgyNzQ2MX0.lzt96XR_xMUdDm3BRGpD40DBww8lUv09gyaTQm5sApc';

create extension if not exists "pg_net";
create extension if not exists "http";

-- 1) Notification Queue (attachments-enabled)
create table if not exists public.notification_queue (
  id            bigint generated always as identity primary key,
  kind          text not null,                          -- otp | email_verified | booking_created | booking_updated | booking_cancelled | invoice
  to_email      text not null,
  subject       text not null,
  html          text not null,
  attachments   jsonb not null default '[]',            -- [{ "name": "...", "url": "https://..." }]
  meta          jsonb not null default '{}',
  status        text not null default 'pending',        -- pending | processing | sent | failed
  try_count     int  not null default 0,
  last_error    text,
  locked_at     timestamptz,
  created_at    timestamptz not null default now(),
  updated_at    timestamptz not null default now()
);

-- helper: updated_at
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end; $$;

drop trigger if exists notification_queue_set_updated on public.notification_queue;
create trigger notification_queue_set_updated
before update on public.notification_queue
for each row execute function public.set_updated_at();

create index if not exists idx_notification_queue_status_created
  on public.notification_queue (status, created_at);
create index if not exists idx_notification_queue_locked
  on public.notification_queue (locked_at);
alter table public.notification_queue
  drop constraint if exists try_count_max;
alter table public.notification_queue
  add constraint try_count_max check (try_count >= 0 and try_count <= 8);

-- 2) Email templates (simple placeholder system)
create table if not exists public.email_templates (
  id text primary key,
  subject_template text not null,
  html_template    text not null,
  updated_at timestamptz not null default now()
);

insert into public.email_templates (id, subject_template, html_template)
values
('otp',
 'Your {{brand}} Verification Code',
 '<div style="font-family:Inter,Arial,sans-serif;padding:16px"><h2>{{otp}}</h2><p>This code expires in 10 minutes.</p><p style="font-size:12px;color:#888">{{brand}}</p></div>'),
('email_verified',
 'Your {{brand}} Email is Verified',
 '<p>Hi {{name}},</p><p>Your email has been verified successfully.</p><p>‚Äî {{brand}}</p>'),
('booking_created',
 '‚úÖ Booking Confirmed ‚Äî #{{booking_id}}',
 '<p>Hi {{name}},</p><p>Your booking for <b>{{service}}</b> is confirmed.</p><p>Date: {{date}} | Time: {{slot}}</p><p>Status: <b>{{status}}</b></p><p>‚Äî {{brand}}</p>'),
('booking_updated',
 'üîÑ Booking Updated ‚Äî #{{booking_id}}',
 '<p>Hi {{name}},</p><p>Your booking for <b>{{service}}</b> has been updated.</p><p>Date: {{date}} | Time: {{slot}}</p><p>Status: <b>{{status}}</b></p><p>‚Äî {{brand}}</p>'),
('booking_cancelled',
 '‚ùå Booking Cancelled ‚Äî #{{booking_id}}',
 '<p>Hi {{name}},</p><p>Your booking for <b>{{service}}</b> has been cancelled.</p><p>If this was a mistake, you can re-book in the HomeFix app.</p><p>‚Äî {{brand}}</p>'),
('invoice',
 'üßæ Your Invoice ‚Äî #{{booking_id}}',
 '<p>Hi {{name}},</p><p>Your invoice and plan are attached.</p><p>‚Äî {{brand}}</p>')
on conflict (id) do nothing;

-- 3) Invoices registry (stores URLs generated by the app)
create table if not exists public.invoices (
  id bigint generated always as identity primary key,
  booking_id bigint not null references public.bookings(id) on delete cascade,
  invoice_url text,
  layout_url  text,
  total numeric(10,2),
  created_at timestamptz default now(),
  metadata jsonb default '{}'::jsonb
);

-- 4) Unified enqueue triggers

-- A) Signup ‚Üí queue OTP (worker will handle OTP email content)
drop function if exists public.notify_user_signup cascade;
create or replace function public.notify_user_signup()
returns trigger language plpgsql security definer as $$
declare
  u_email text;
begin
  select email into u_email from auth.users where id = new.id;
  if u_email is null then
    return new;
  end if;

  insert into public.notification_queue(kind, to_email, subject, html, meta)
  values (
    'otp',
    u_email,
    'Your Verification Code',            -- worker will override using template
    '<p>OTP will be inserted by worker.</p>',
    jsonb_build_object('user_id', new.id)
  );

  return new;
end; $$;

drop trigger if exists trigger_user_signup on public.user_profiles;
create trigger trigger_user_signup
after insert on public.user_profiles
for each row execute function public.notify_user_signup();

-- B) Email verified ‚Üí queue info mail
drop function if exists public.notify_email_verified cascade;
create or replace function public.notify_email_verified()
returns trigger language plpgsql security definer as $$
declare
  u_email text;
  u_name  text;
begin
  if new.email_verified is true and old.email_verified is distinct from new.email_verified then
    select email into u_email from auth.users where id = new.id;
    select name  into u_name  from public.user_profiles where id = new.id;

    if u_email is not null then
      insert into public.notification_queue(kind, to_email, subject, html, meta)
      values (
        'email_verified',
        u_email,
        'Your Email is Verified',
        '<p>Your email is verified.</p>',
        jsonb_build_object('user_id', new.id, 'name', u_name)
      );
    end if;
  end if;

  return new;
end; $$;

drop trigger if exists trigger_email_verified on public.user_profiles;
create trigger trigger_email_verified
after update on public.user_profiles
for each row execute function public.notify_email_verified();

-- C) Booking activity ‚Üí queue mail (created / updated / cancelled)
drop function if exists public.notify_booking_activity cascade;
create or replace function public.notify_booking_activity()
returns trigger language plpgsql security definer as $$
declare
  event_action text;
  u_email text;
  u_name  text;
  svc     text;
  v_date  text;
  v_slot  text;
begin
  if tg_op = 'INSERT' then
    event_action := 'booking_created';
  elsif tg_op = 'UPDATE' then
    if old.status is distinct from new.status and new.status ilike '%cancel%' then
      event_action := 'booking_cancelled';
    elsif old.status is distinct from new.status then
      event_action := 'booking_updated';
    else
      return new;
    end if;
  else
    return new;
  end if;

  select email into u_email from auth.users where id = new.user_id;
  select name  into u_name  from public.user_profiles where id = new.user_id;

  begin
    select coalesce((new.services->0->>'name'),'HomeFix Service') into svc;
  exception when others then svc := 'HomeFix Service';
  end;

  v_date := coalesce(new.preferred_date::text,'-');
  v_slot := coalesce(new.preferred_slot,'-');

  if u_email is not null then
    insert into public.notification_queue(kind, to_email, subject, html, meta)
    values (
      event_action,
      u_email,
      'Booking Event',  -- worker will render template
      '<p>Booking event will be rendered by worker.</p>',
      jsonb_build_object(
        'booking_id', new.id,
        'user_id', new.user_id,
        'name', u_name,
        'service', svc,
        'date', v_date,
        'slot', v_slot,
        'status', new.status
      )
    );
  end if;

  return new;
end; $$;

drop trigger if exists trigger_booking_activity on public.bookings;
create trigger trigger_booking_activity
after insert or update on public.bookings
for each row execute function public.notify_booking_activity();

-- D) Invoice inserted ‚Üí queue mail with attachments
drop function if exists public.notify_invoice_generated cascade;
create or replace function public.notify_invoice_generated()
returns trigger language plpgsql security definer as $$
declare
  u_email text;
  u_name  text;
begin
  select email into u_email from auth.users u
  join public.bookings b on b.user_id = u.id
  where b.id = new.booking_id;

  select name into u_name from public.user_profiles p
  join public.bookings b on b.user_id = p.id
  where b.id = new.booking_id;

  if u_email is not null then
    insert into public.notification_queue(kind, to_email, subject, html, attachments, meta)
    values (
      'invoice',
      u_email,
      'Your Invoice',
      '<p>Your invoice and plan are attached.</p>',
      jsonb_build_array(
        case when new.invoice_url is not null then jsonb_build_object('name', 'invoice.pdf', 'url', new.invoice_url) end,
        case when new.layout_url  is not null then jsonb_build_object('name', 'layout.pdf',  'url', new.layout_url)  end
      ),
      jsonb_build_object('booking_id', new.booking_id, 'name', u_name)
    );
  end if;

  return new;
end; $$;

drop trigger if exists trigger_invoice_generated on public.invoices;
create trigger trigger_invoice_generated
after insert on public.invoices
for each row execute function public.notify_invoice_generated();
